# test_md5_bruteforce.py
import pyopencl as cl
import numpy as np
import time
import sys
import hashlib # For generating target hash initially
from itertools import product
import string # Added for charset

# --- Helper function to get index of a candidate ---
def get_candidate_index(candidate_str, charset):
    """Calculates the index of a candidate string in the sequence generated by product(charset, repeat=len(candidate_str))."""
    base = len(charset)
    index = 0
    power = 1
    # Process string from right to left
    for char in reversed(candidate_str):
        try:
            char_index = charset.index(char)
        except ValueError:
            # Character not in charset, invalid candidate for this sequence
            return -1 
        index += char_index * power
        power *= base
    return index

# --- Include the get_clover_turks_context function here ---
# (Or import it if you put it in a separate file)
def get_clover_turks_context():
    # ... (Paste the function definition from test_gpu3.py here) ...
    # ... (Or modify to import if moved to a utility file) ...
    target_platform_name = "Clover"
    target_device_name = "AMD TURKS"
    platform = None
    device = None

    print("Looking for OpenCL platforms and devices...")
    try:
        platforms = cl.get_platforms()
        if not platforms:
            print("ERROR: No OpenCL platforms found!")
            return None

        for p in platforms:
            p_name = p.get_info(cl.platform_info.NAME).strip()
            if target_platform_name in p_name:
                platform = p
                try:
                    gpu_devices = platform.get_devices(device_type=cl.device_type.GPU)
                    if not gpu_devices: continue

                    for d in gpu_devices:
                        d_name = d.get_info(cl.device_info.NAME).strip()
                        if target_device_name in d_name:
                            device = d
                            print(f"\nUsing Platform: {p_name}")
                            print(f"Using Device: {d_name}\n")
                            # Check OpenCL version
                            cl_version_str = device.get_info(cl.device_info.VERSION)
                            print(f"Device OpenCL Version: {cl_version_str}")
                            # Basic check for 1.1 for atomics
                            if "OpenCL 1.0" in cl_version_str:
                                print("WARNING: OpenCL 1.0 detected. atom_cmpxchg might not be available.")
                            elif "OpenCL 1." in cl_version_str or "OpenCL 2." in cl_version_str or "OpenCL 3." in cl_version_str:
                                print("OpenCL 1.1+ detected, atomics should be available.")
                            else:
                                 print("Warning: Could not determine OpenCL version reliably.")

                            break
                    if device: break
                except cl.Error as e:
                     print(f"  -> CL Error getting devices for '{p_name}': {e}")
                except Exception as e:
                     print(f"  -> Error getting devices for '{p_name}': {e}")


        if not device:
            print(f"ERROR: Target device '{target_device_name}' on platform '{target_platform_name}' not found.")
            print("Check 'clinfo' output again for the exact device name.")
            return None

        return cl.Context([device])

    except cl.Error as e:
        print(f"OpenCL setup error: {e}")
        return None
    except Exception as e:
        print(f"Unexpected error during setup: {e}")
        return None
# --- End of get_clover_turks_context ---


# --- CPU Brute-force Function (Modified for Debug Window) ---
def cpu_bruteforce(target_hash_hex, charset, length, debug_start_idx=-1, debug_end_idx=-1):
    print(f"\nStarting CPU brute-force for length {length} with charset '{charset}'...")
    if debug_start_idx >= 0 and debug_end_idx >= 0:
        print(f"  (Debug output focused on index range: {debug_start_idx} to {debug_end_idx})")
        
    start_time = time.time()
    count = 0
    total_keys = len(charset)**length
    found_password = None
    
    for guess_tuple in product(charset, repeat=length):
        guess = "".join(guess_tuple)
        current_idx = count # Index is 0-based, count starts at 0
        count += 1

        # Standard progress indicator
        if count % 100000 == 0 or count == total_keys: 
             print(f"  CPU Checked: {count}/{total_keys} ({count*100/total_keys:.2f}%)".ljust(70), end='\r')

        # Detailed debug print only for candidates within the specified window
        # Always hash if it might be the target, otherwise only hash if in debug window
        should_hash = (guess == TARGET_PASSWORD) or (debug_start_idx <= current_idx <= debug_end_idx)

        if should_hash:
            hashed_guess = hashlib.md5(guess.encode('ascii')).hexdigest()
            is_match = (hashed_guess == target_hash_hex)

            if debug_start_idx <= current_idx <= debug_end_idx:
                match_status = "MATCH!" if is_match else "No match"
                # Add extra space to clear previous progress line if needed
                print(f"  CPU DBG [{current_idx}]: Guess='{guess}', Hash={hashed_guess[:8]}..., Status={match_status}   ") 

            if is_match:
                found_password = guess
                # Optional: break here if you only want the first match and its debug context
                # break 

    # --- End of Loop ---
    end_time = time.time()
    cpu_time = end_time - start_time
    # Use total_keys for rate calculation as we iterate through all even if debugging subset
    hashes_sec = total_keys / cpu_time if cpu_time > 0 else 0

    if found_password:
        print(f"\nCPU Found: '{found_password}' in {cpu_time:.4f} seconds ({total_keys} scanned, focus range {debug_start_idx}-{debug_end_idx}).")
        print(f"CPU Hash Rate (overall): {hashes_sec:,.2f} hashes/sec")
        return found_password, cpu_time, hashes_sec
    else:
        print(f"\nCPU Finished: Password not found in {cpu_time:.4f} seconds ({total_keys} scanned)." )
        print(f"CPU Hash Rate (overall): {hashes_sec:,.2f} hashes/sec")
        return None, cpu_time, hashes_sec


# --- Configuration ---
# PASSWORD_LEN = 2 # No longer needed, derived from TARGET_PASSWORD
CHARSET = string.digits
CHARSET_LEN = len(CHARSET)

TARGET_PASSWORD = "123" # Changed to 3-digit password
PASSWORD_LEN = len(TARGET_PASSWORD) # Automatically set length
TARGET_HASH_STR = hashlib.md5(TARGET_PASSWORD.encode('ascii')).hexdigest()
TARGET_HASH_BYTES = bytes.fromhex(TARGET_HASH_STR)
print(TARGET_HASH_BYTES)
print(f"Target Password: {TARGET_PASSWORD}")
print(f"Target MD5 Hash (hex): {TARGET_HASH_STR}")
print(f"Password Length: {PASSWORD_LEN}")
print(f"Character Set: '{CHARSET}' ({CHARSET_LEN} chars)")

keyspace_size = CHARSET_LEN ** PASSWORD_LEN
print(f"Total Keyspace Size: {keyspace_size:,}")

# --- Calculate Debug Window for CPU --- 
DEBUG_WINDOW = 5 # Show +/- 5 candidates around the target
target_idx = get_candidate_index(TARGET_PASSWORD, CHARSET)
if target_idx != -1:
    debug_start_idx = max(0, target_idx - DEBUG_WINDOW)
    debug_end_idx = min(keyspace_size - 1, target_idx + DEBUG_WINDOW)
else:
    print(f"Warning: Target password '{TARGET_PASSWORD}' contains characters not in charset '{CHARSET}'. Disabling debug window.")
    debug_start_idx = -1
    debug_end_idx = -1

# --- Run CPU Test --- 
cpu_found_pw, cpu_time, cpu_hashes_sec = cpu_bruteforce(TARGET_HASH_STR, CHARSET, PASSWORD_LEN, debug_start_idx, debug_end_idx)
print("-" * 20)

# Initialize GPU variables in case GPU part fails before assignment
gpu_time = -1.0
gpu_hashes_sec = 0.0
gpu_found_pw_str = None

# --- OpenCL Setup ---
print("Starting GPU setup...")
context = get_clover_turks_context()
if not context:
    sys.exit(1)

device = context.devices[0]
queue = cl.CommandQueue(context)

# --- Data Buffers ---
mf = cl.mem_flags

# Target hash buffer (uchar[16])
target_hash_buf = cl.Buffer(context, mf.READ_ONLY | mf.COPY_HOST_PTR, hostbuf=np.frombuffer(TARGET_HASH_BYTES, dtype=np.uint8))

# Charset buffer (uchar[charset_len])
charset_bytes = CHARSET.encode('ascii')
charset_buf = cl.Buffer(context, mf.READ_ONLY | mf.COPY_HOST_PTR, hostbuf=np.frombuffer(charset_bytes, dtype=np.uint8))

# Dummy buffers required by kernel signature but unused by debug logic
result_found_host = np.array([0], dtype=np.int32)
result_found_buf = cl.Buffer(context, mf.READ_WRITE | mf.COPY_HOST_PTR, hostbuf=result_found_host)
found_password_host_dummy = np.zeros(1 + 1, dtype=np.uint8) # Len 1 + null
found_password_buf = cl.Buffer(context, mf.WRITE_ONLY, found_password_host_dummy.nbytes)

# Actual Debug Output Buffer (for 3-digit kernel, size 1000*20)
GPU_DEBUG_KEYSPACE = 1000 # Size expected by the .cl file for 3 digits
DEBUG_ENTRY_SIZE = 1 + 3 + 16 # 1 byte for match, 3 bytes for password, 16 bytes for hash
DEBUG_BUFFER_SIZE = GPU_DEBUG_KEYSPACE * DEBUG_ENTRY_SIZE
debug_output_host = np.zeros(DEBUG_BUFFER_SIZE, dtype=np.uint8)
debug_output_buf = cl.Buffer(context, mf.WRITE_ONLY, debug_output_host.nbytes)


# --- Kernel Source --- 
# Read kernel code from external file (still points to the 1-digit debug kernel)
KERNEL_FILE = "bruteforce_md5_debug.cl"
try:
    with open(KERNEL_FILE, 'r') as f:
        kernel_source = f.read()
except FileNotFoundError:
    print(f"ERROR: Kernel file '{KERNEL_FILE}' not found.")
    sys.exit(1)

# --- Compile Kernel ---
print("Compiling kernel...")
try:
    program = cl.Program(context, kernel_source).build()
    # Change kernel function name to match the one we defined
    bruteforce_kernel = program.bruteforce_md5_debug
    print("Kernel compiled successfully.")
except cl.RuntimeError as e:
    print("!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!")
    print("ERROR: Kernel compilation failed!")
    # print(f"(Likely because the kernel source is incomplete/incorrect)") # Old message
    print(f"Error details: {e}")
    try:
        build_log = program.get_build_info(device, cl.program_build_info.LOG)
        # Mesa/Clover logs can be verbose, print only first/last few lines maybe
        log_lines = build_log.splitlines()
        print("Build Log (Excerpt):")
        if len(log_lines) > 20:
            for line in log_lines[:10]: print(line)
            print("...")
            for line in log_lines[-10:]: print(line)
        else:
            print(build_log)

    except Exception as log_err:
         print(f"(Could not retrieve build log: {log_err})")
    print("Common issues: syntax errors, missing OpenCL extensions (like byte_addressable_store), incorrect atomic function usage.")
    print("!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!")
    sys.exit(1)
except cl.Error as e:
    print(f"ERROR during kernel compilation setup: {e}")
    sys.exit(1)
except Exception as e:
     print(f"An unexpected error occurred during compilation setup: {e}")
     sys.exit(1)


# --- Execute Kernel (Still running the 1-digit debug kernel) --- 
print("Executing GPU kernel (NOTE: Using 3-digit debug kernel from .cl file)...")
# Use keyspace size appropriate for the 3-digit kernel
global_size = (GPU_DEBUG_KEYSPACE,)
local_size = None

# Pass arguments appropriate for the 3-digit debug kernel
# Need to pass length=3 to match the kernel's expectation
gpu_password_len_arg = np.int32(3)
# Define charset_len_arg (was missing)
charset_len_arg = np.int32(CHARSET_LEN)

gpu_success = False

try:
    bruteforce_kernel.set_args(target_hash_buf,
                               charset_buf,
                               charset_len_arg,
                               gpu_password_len_arg, # Pass 3 for kernel
                               result_found_buf,    # Dummy
                               found_password_buf,  # Dummy
                               debug_output_buf)

    print(f"Launching {GPU_DEBUG_KEYSPACE} work items for 3-digit debug kernel...")
    start_time = time.time()
    exec_event = cl.enqueue_nd_range_kernel(queue, bruteforce_kernel, global_size, local_size)
    exec_event.wait()
    queue.finish()
    end_time = time.time()
    gpu_time = end_time - start_time
    gpu_hashes_sec = GPU_DEBUG_KEYSPACE / gpu_time if gpu_time > 0 else 0
    print(f"GPU Kernel execution finished in {gpu_time:.4f} seconds.")
    print(f"GPU Hash Rate (3-digit kernel): {gpu_hashes_sec:,.2f} hashes/sec")

    print("\n--- Reading and Processing GPU Debug Output Buffer ---")
    cl.enqueue_copy(queue, debug_output_host, debug_output_buf).wait()
    gpu_success = True

    print("GPU GID | Candidate | Expected Match? (vs '{TARGET_PASSWORD}') | GPU Match? | GPU Hash (Hex, first 8 bytes)".format(TARGET_PASSWORD=TARGET_PASSWORD))
    print("--------|-----------|-----------------------------|------------|--------------------------------")
    overall_match = True
    for gid in range(GPU_DEBUG_KEYSPACE):
        offset = gid * DEBUG_ENTRY_SIZE
        # The kernel stores the password first, then the hash, then the match status
        # But the Python code is reading it differently
        gpu_match_result = int(debug_output_host[offset + 19])  # Match status is at offset + 19
        
        # Use safe encoding/decoding to handle non-ASCII characters
        try:
            gpu_candidate_char1 = chr(debug_output_host[offset])
            gpu_candidate_char2 = chr(debug_output_host[offset + 1])
            gpu_candidate_char3 = chr(debug_output_host[offset + 2])
            gpu_candidate = gpu_candidate_char1 + gpu_candidate_char2 + gpu_candidate_char3
        except (UnicodeDecodeError, ValueError):
            # Fallback for non-ASCII characters
            gpu_candidate = f"<{debug_output_host[offset]:02x}{debug_output_host[offset + 1]:02x}{debug_output_host[offset + 2]:02x}>"
        
        gpu_hash_bytes = debug_output_host[offset + 3 : offset + 3 + 16].tobytes()
        py_hash_bytes = hashlib.md5(gpu_candidate.encode('ascii', errors='replace')).digest()
        expected_match = 1 if (py_hash_bytes == TARGET_HASH_BYTES) else 0
        expected_match_str = "Yes" if expected_match == 1 else "No "
        gpu_match_str = "Yes" if gpu_match_result == 1 else "No "
        match_status = "PASS" if (gpu_match_result == expected_match) else "FAIL"
        if match_status == "FAIL": overall_match = False
        print(f"{gid: <7} | '{gpu_candidate}'     | {expected_match_str: <27} | {gpu_match_str: <10} | {gpu_hash_bytes[:8].hex()}... ({match_status})")

    print("------------------------------------------------------------------------------------------")
    if overall_match:
        print("GPU Overall Result: PASSED - GPU comparison results match expected results for all 3-digit candidates.")
    else:
        print("GPU Overall Result: FAILED - GPU comparison results differ from expected for one or more 3-digit candidates.")

except cl.Error as e:
    print(f"\nAn OpenCL error occurred during execution/copy: {e.what()} (Code: {e.code})")
    gpu_success = False
except Exception as e:
    print(f"\nAn unexpected error occurred: {e}")
    gpu_success = False
finally:
    # Release ALL buffers, including the new debug one
    try:
        target_hash_buf.release()
        charset_buf.release()
        result_found_buf.release()
        found_password_buf.release()
        debug_output_buf.release() # Release new buffer
    except Exception as e:
        print(f"Error releasing buffers: {e}")

    # --- Simplified Analysis Summary for Debug Run --- 
    print("\n" + "="*30)
    print("      Analysis Summary (3-Digit Debug)")
    print("="*30)
    print(f"Target Password: '{TARGET_PASSWORD}'")
    print(f"Keyspace Size: {keyspace_size}")
    print("-" * 30)
    print(f"CPU Time : {cpu_time:.4f} sec ({cpu_hashes_sec:,.0f} H/s)")
    if gpu_success:
        print(f"GPU Time : {gpu_time:.4f} sec ({gpu_hashes_sec:,.0f} H/s)")
        print(f"GPU Debug: {'PASSED' if overall_match else 'FAILED'}")
    else:
        print("GPU Time : N/A (Run Failed)")
        print("GPU Debug: N/A")
    print("="*30)

    print("Script finished.") 