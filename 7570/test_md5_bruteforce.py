# test_md5_bruteforce.py
import pyopencl as cl
import numpy as np
import time
import sys
import hashlib # For generating target hash initially
from itertools import product
import string # Added for charset

# --- Helper function to get index of a candidate ---
def get_candidate_index(candidate_str, charset):
    """Calculates the index of a candidate string in the sequence generated by product(charset, repeat=len(candidate_str))."""
    base = len(charset)
    index = 0
    power = 1
    # Process string from right to left
    for char in reversed(candidate_str):
        try:
            char_index = charset.index(char)
        except ValueError:
            # Character not in charset, invalid candidate for this sequence
            return -1 
        index += char_index * power
        power *= base
    return index

# --- Include the get_clover_turks_context function here ---
# (Or import it if you put it in a separate file)
def get_clover_turks_context():
    # ... (Paste the function definition from test_gpu3.py here) ...
    # ... (Or modify to import if moved to a utility file) ...
    target_platform_name = "Clover"
    target_device_name = "AMD TURKS"
    platform = None
    device = None

    print("Looking for OpenCL platforms and devices...")
    try:
        platforms = cl.get_platforms()
        if not platforms:
            print("ERROR: No OpenCL platforms found!")
            return None

        for p in platforms:
            p_name = p.get_info(cl.platform_info.NAME).strip()
            if target_platform_name in p_name:
                platform = p
                try:
                    gpu_devices = platform.get_devices(device_type=cl.device_type.GPU)
                    if not gpu_devices: continue

                    for d in gpu_devices:
                        d_name = d.get_info(cl.device_info.NAME).strip()
                        if target_device_name in d_name:
                            device = d
                            print(f"\nUsing Platform: {p_name}")
                            print(f"Using Device: {d_name}\n")
                            # Check OpenCL version
                            cl_version_str = device.get_info(cl.device_info.VERSION)
                            print(f"Device OpenCL Version: {cl_version_str}")
                            # Basic check for 1.1 for atomics
                            if "OpenCL 1.0" in cl_version_str:
                                print("WARNING: OpenCL 1.0 detected. atom_cmpxchg might not be available.")
                            elif "OpenCL 1." in cl_version_str or "OpenCL 2." in cl_version_str or "OpenCL 3." in cl_version_str:
                                print("OpenCL 1.1+ detected, atomics should be available.")
                            else:
                                 print("Warning: Could not determine OpenCL version reliably.")

                            break
                    if device: break
                except cl.Error as e:
                     print(f"  -> CL Error getting devices for '{p_name}': {e}")
                except Exception as e:
                     print(f"  -> Error getting devices for '{p_name}': {e}")


        if not device:
            print(f"ERROR: Target device '{target_device_name}' on platform '{target_platform_name}' not found.")
            print("Check 'clinfo' output again for the exact device name.")
            return None

        return cl.Context([device])

    except cl.Error as e:
        print(f"OpenCL setup error: {e}")
        return None
    except Exception as e:
        print(f"Unexpected error during setup: {e}")
        return None
# --- End of get_clover_turks_context ---


# --- CPU Brute-force Function (Modified for Debug Window) ---
def cpu_bruteforce(target_hash_hex, charset, length, debug_start_idx=-1, debug_end_idx=-1):
    print(f"\nStarting CPU brute-force for length {length} with charset '{charset}'...")
    if debug_start_idx >= 0 and debug_end_idx >= 0:
        print(f"  (Debug output focused on index range: {debug_start_idx} to {debug_end_idx})")
        
    start_time = time.time()
    count = 0
    total_keys = len(charset)**length
    found_password = None
    
    for guess_tuple in product(charset, repeat=length):
        guess = "".join(guess_tuple)
        current_idx = count # Index is 0-based, count starts at 0
        count += 1

        # Standard progress indicator
        if count % 100000 == 0 or count == total_keys: 
             print(f"  CPU Checked: {count}/{total_keys} ({count*100/total_keys:.2f}%)".ljust(70), end='\r')

        # Detailed debug print only for candidates within the specified window
        # Always hash if it might be the target, otherwise only hash if in debug window
        should_hash = (guess == TARGET_PASSWORD) or (debug_start_idx <= current_idx <= debug_end_idx)

        if should_hash:
            hashed_guess = hashlib.md5(guess.encode('ascii')).hexdigest()
            is_match = (hashed_guess == target_hash_hex)

            if debug_start_idx <= current_idx <= debug_end_idx:
                match_status = "MATCH!" if is_match else "No match"
                # Add extra space to clear previous progress line if needed
                print(f"  CPU DBG [{current_idx}]: Guess='{guess}', Hash={hashed_guess[:8]}..., Status={match_status}   ") 

            if is_match:
                found_password = guess
                # Optional: break here if you only want the first match and its debug context
                # break 

    # --- End of Loop ---
    end_time = time.time()
    cpu_time = end_time - start_time
    # Use total_keys for rate calculation as we iterate through all even if debugging subset
    hashes_sec = total_keys / cpu_time if cpu_time > 0 else 0

    if found_password:
        print(f"\nCPU Found: '{found_password}' in {cpu_time:.4f} seconds ({total_keys} scanned, focus range {debug_start_idx}-{debug_end_idx}).")
        print(f"CPU Hash Rate (overall): {hashes_sec:,.2f} hashes/sec")
        return found_password, cpu_time, hashes_sec
    else:
        print(f"\nCPU Finished: Password not found in {cpu_time:.4f} seconds ({total_keys} scanned)." )
        print(f"CPU Hash Rate (overall): {hashes_sec:,.2f} hashes/sec")
        return None, cpu_time, hashes_sec


# --- Configuration ---
CHARSET = string.digits
CHARSET_LEN = len(CHARSET)

TARGET_PASSWORD = "1234" # Changed to 4-digit password
PASSWORD_LEN = len(TARGET_PASSWORD) # Automatically set length
TARGET_HASH_STR = hashlib.md5(TARGET_PASSWORD.encode('ascii')).hexdigest()
TARGET_HASH_BYTES = bytes.fromhex(TARGET_HASH_STR)
print(TARGET_HASH_STR)
print(f"Target Password: {TARGET_PASSWORD}")
print(f"Target MD5 Hash (hex): {TARGET_HASH_STR}")
print(f"Password Length: {PASSWORD_LEN}")
print(f"Character Set: '{CHARSET}' ({CHARSET_LEN} chars)")

keyspace_size = CHARSET_LEN ** PASSWORD_LEN
print(f"Total Keyspace Size: {keyspace_size:,}")

# --- Calculate Debug Window for CPU --- 
DEBUG_WINDOW = 5 # Show +/- 5 candidates around the target
target_idx = get_candidate_index(TARGET_PASSWORD, CHARSET)
if target_idx != -1:
    debug_start_idx = max(0, target_idx - DEBUG_WINDOW)
    debug_end_idx = min(keyspace_size - 1, target_idx + DEBUG_WINDOW)
else:
    print(f"Warning: Target password '{TARGET_PASSWORD}' contains characters not in charset '{CHARSET}'. Disabling debug window.")
    debug_start_idx = -1
    debug_end_idx = -1

# --- Run CPU Test --- 
cpu_found_pw, cpu_time, cpu_hashes_sec = cpu_bruteforce(TARGET_HASH_STR, CHARSET, PASSWORD_LEN, debug_start_idx, debug_end_idx)
print("-" * 20)

# Initialize GPU variables in case GPU part fails before assignment
gpu_time = -1.0
gpu_hashes_sec = 0.0
gpu_found_pw_str = None

# --- OpenCL Setup ---
print("Starting GPU setup...")
context = get_clover_turks_context()
if not context:
    sys.exit(1)

device = context.devices[0]
queue = cl.CommandQueue(context)

# --- Data Buffers ---
mf = cl.mem_flags

# Target hash buffer (uchar[16])
target_hash_buf = cl.Buffer(context, mf.READ_ONLY | mf.COPY_HOST_PTR, 
                          hostbuf=np.frombuffer(TARGET_HASH_BYTES, dtype=np.uint8))

# Charset buffer (uchar[charset_len])
charset_bytes = np.frombuffer(CHARSET.encode('ascii'), dtype=np.uint8)
charset_buf = cl.Buffer(context, mf.READ_ONLY | mf.COPY_HOST_PTR, 
                       hostbuf=charset_bytes)

# Result buffers
result_found_host = np.zeros(1, dtype=np.int32)
result_found_buf = cl.Buffer(context, mf.READ_WRITE | mf.COPY_HOST_PTR, 
                           hostbuf=result_found_host)

found_password_host = np.zeros(PASSWORD_LEN, dtype=np.uint8)
found_password_buf = cl.Buffer(context, mf.WRITE_ONLY, found_password_host.nbytes)

# Debug Output Buffer
GPU_DEBUG_KEYSPACE = 10000 # Size expected for 4 digits
DEBUG_ENTRY_SIZE = PASSWORD_LEN + 16 + 1 # password + hash + match status
DEBUG_BUFFER_SIZE = GPU_DEBUG_KEYSPACE * DEBUG_ENTRY_SIZE
debug_output_host = np.zeros(DEBUG_BUFFER_SIZE, dtype=np.uint8)
debug_output_buf = cl.Buffer(context, mf.WRITE_ONLY, debug_output_host.nbytes)


# --- Kernel Source --- 
# Read kernel code from external file (still points to the 1-digit debug kernel)
KERNEL_FILE = "bruteforce_md5_debug.cl"
try:
    with open(KERNEL_FILE, 'r') as f:
        kernel_source = f.read()
except FileNotFoundError:
    print(f"ERROR: Kernel file '{KERNEL_FILE}' not found.")
    sys.exit(1)

# --- Compile Kernel ---
print("Compiling kernel...")
try:
    program = cl.Program(context, kernel_source).build()
    # Change kernel function name to match the one we defined
    bruteforce_kernel = program.bruteforce_md5_debug
    print("Kernel compiled successfully.")
except cl.RuntimeError as e:
    print("!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!")
    print("ERROR: Kernel compilation failed!")
    # print(f"(Likely because the kernel source is incomplete/incorrect)") # Old message
    print(f"Error details: {e}")
    try:
        build_log = program.get_build_info(device, cl.program_build_info.LOG)
        # Mesa/Clover logs can be verbose, print only first/last few lines maybe
        log_lines = build_log.splitlines()
        print("Build Log (Excerpt):")
        if len(log_lines) > 20:
            for line in log_lines[:10]: print(line)
            print("...")
            for line in log_lines[-10:]: print(line)
        else:
            print(build_log)

    except Exception as log_err:
         print(f"(Could not retrieve build log: {log_err})")
    print("Common issues: syntax errors, missing OpenCL extensions (like byte_addressable_store), incorrect atomic function usage.")
    print("!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!")
    sys.exit(1)
except cl.Error as e:
    print(f"ERROR during kernel compilation setup: {e}")
    sys.exit(1)
except Exception as e:
     print(f"An unexpected error occurred during compilation setup: {e}")
     sys.exit(1)


# --- Execute Kernel ---
print("Executing GPU kernel (NOTE: Using 4-digit debug kernel from .cl file)...")
global_size = (GPU_DEBUG_KEYSPACE,)
local_size = None

gpu_password_len_arg = np.int32(PASSWORD_LEN)
charset_len_arg = np.int32(CHARSET_LEN)

gpu_success = False

try:
    bruteforce_kernel.set_args(target_hash_buf,
                              charset_buf,
                              charset_len_arg,
                              gpu_password_len_arg,
                              result_found_buf,
                              found_password_buf,
                              debug_output_buf)

    print(f"Launching {GPU_DEBUG_KEYSPACE} work items for {PASSWORD_LEN}-digit debug kernel...")
    start_time = time.time()
    exec_event = cl.enqueue_nd_range_kernel(queue, bruteforce_kernel, global_size, local_size)
    exec_event.wait()
    queue.finish()
    end_time = time.time()
    gpu_time = end_time - start_time
    gpu_hashes_sec = GPU_DEBUG_KEYSPACE / gpu_time if gpu_time > 0 else 0
    print(f"GPU Kernel execution finished in {gpu_time:.4f} seconds.")
    print(f"GPU Hash Rate ({PASSWORD_LEN}-digit kernel): {gpu_hashes_sec:,.2f} hashes/sec")

    print("\n--- Reading and Processing GPU Debug Output Buffer ---")
    cl.enqueue_copy(queue, debug_output_host, debug_output_buf).wait()
    gpu_success = True

    # Count matches and mismatches
    match_count = 0
    mismatch_count = 0
    total_checked = 0
    
    # Track mismatches by position
    mismatch_positions = []
    mismatch_examples = []

    # Find the target password's index
    target_idx = get_candidate_index(TARGET_PASSWORD, CHARSET)
    if target_idx == -1:
        print("Warning: Target password not found in charset sequence")
        target_idx = 0

    # Calculate the range to display (5 entries before and after target)
    start_idx = max(0, target_idx - 5)
    end_idx = min(GPU_DEBUG_KEYSPACE - 1, target_idx + 5)

    # Print header for debug entries
    print("\nDebug entries around target password:")
    print("GID | Candidate | Expected Match? | GPU Match? | GPU Hash (first 8 bytes)")
    print("-" * 75)

    for gid in range(GPU_DEBUG_KEYSPACE):
        offset = gid * DEBUG_ENTRY_SIZE
        
        # Extract password characters
        password_chars = debug_output_host[offset:offset + PASSWORD_LEN]
        try:
            gpu_candidate = bytes(password_chars).decode('ascii')
        except UnicodeDecodeError:
            gpu_candidate = ''.join(f'\\x{b:02x}' for b in password_chars)
        
        # Extract hash and match status
        gpu_hash_bytes = debug_output_host[offset + PASSWORD_LEN:offset + PASSWORD_LEN + 16]
        gpu_match_result = debug_output_host[offset + PASSWORD_LEN + 16]
        
        # Calculate expected match
        py_hash_bytes = hashlib.md5(gpu_candidate.encode('ascii', errors='replace')).digest()
        expected_match = 1 if (py_hash_bytes == TARGET_HASH_BYTES) else 0
        
        if gpu_match_result == expected_match:
            match_count += 1
        else:
            mismatch_count += 1
            # Store the first 10 mismatches for analysis
            if len(mismatch_examples) < 10:
                mismatch_examples.append({
                    'gid': gid,
                    'candidate': gpu_candidate,
                    'gpu_hash': bytes(gpu_hash_bytes).hex(),
                    'py_hash': py_hash_bytes.hex(),
                    'gpu_match': gpu_match_result,
                    'expected_match': expected_match
                })
            mismatch_positions.append(gid)
        total_checked += 1

        # Only print entries within our display range
        if start_idx <= gid <= end_idx:
            expected_match_str = "Yes" if expected_match == 1 else "No "
            gpu_match_str = "Yes" if gpu_match_result == 1 else "No "
            match_status = "PASS" if (gpu_match_result == expected_match) else "FAIL"
            print(f"{gid: <4} | '{gpu_candidate}' | {expected_match_str: <13} | {gpu_match_str: <10} | {bytes(gpu_hash_bytes[:8]).hex()}... ({match_status})")

    print("-" * 75)

    # Print summary
    print("\nGPU Debug Summary:")
    print(f"Total candidates checked: {total_checked}")
    print(f"Matching results: {match_count}")
    print(f"Mismatching results: {mismatch_count}")
    print(f"Accuracy: {(match_count/total_checked)*100:.2f}%")
    
    # Print mismatch analysis
    if mismatch_count > 0:
        print("\nMismatch Analysis:")
        print(f"First 10 mismatches:")
        for i, mismatch in enumerate(mismatch_examples):
            print(f"  {i+1}. GID: {mismatch['gid']}, Candidate: '{mismatch['candidate']}'")
            print(f"     GPU Hash: {mismatch['gpu_hash']}")
            print(f"     Py Hash:  {mismatch['py_hash']}")
            print(f"     GPU Match: {mismatch['gpu_match']}, Expected: {mismatch['expected_match']}")
        
        # Check if mismatches follow a pattern
        if len(mismatch_positions) > 1:
            diffs = [mismatch_positions[i+1] - mismatch_positions[i] for i in range(len(mismatch_positions)-1)]
            unique_diffs = set(diffs)
            if len(unique_diffs) < 10:  # If there are fewer than 10 unique differences
                print(f"\nMismatch pattern detected: {sorted(unique_diffs)}")
    
    if mismatch_count == 0:
        print("\nGPU Overall Result: PASSED - All hash comparisons match expected results")
    else:
        print("\nGPU Overall Result: FAILED - Some hash comparisons differ from expected")

except cl.Error as e:
    print(f"\nAn OpenCL error occurred during execution/copy: {e.what()} (Code: {e.code})")
    gpu_success = False
except Exception as e:
    print(f"\nAn unexpected error occurred: {e}")
    gpu_success = False
finally:
    # Release ALL buffers
    try:
        target_hash_buf.release()
        charset_buf.release()
        result_found_buf.release()
        found_password_buf.release()
        debug_output_buf.release()
    except Exception as e:
        print(f"Error releasing buffers: {e}")

    # --- Analysis Summary ---
    print("\n" + "="*30)
    print(f"      Analysis Summary ({PASSWORD_LEN}-Digit Debug)")
    print("="*30)
    print(f"Target Password: '{TARGET_PASSWORD}'")
    print(f"Keyspace Size: {keyspace_size}")
    print("-" * 30)
    print(f"CPU Time : {cpu_time:.4f} sec ({cpu_hashes_sec:,.0f} H/s)")
    if gpu_success:
        print(f"GPU Time : {gpu_time:.4f} sec ({gpu_hashes_sec:,.0f} H/s)")
        print(f"GPU Debug: {'PASSED' if mismatch_count == 0 else 'FAILED'}")
    else:
        print("GPU Time : N/A (Run Failed)")
        print("GPU Debug: N/A")
    print("="*30)

    print("Script finished.") 